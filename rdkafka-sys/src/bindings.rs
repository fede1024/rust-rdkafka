/* automatically generated by rust-bindgen 0.56.0 */

use libc::{c_char, c_int, c_void, size_t, sockaddr, ssize_t, FILE};
use num_enum::TryFromPrimitive;

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const RD_KAFKA_VERSION: u32 = 17236223;
pub const RD_KAFKA_DEBUG_CONTEXTS : & 'static [u8 ; 138usize] = b"all,generic,broker,topic,metadata,feature,queue,msg,protocol,cgrp,security,fetch,interceptor,plugin,consumer,admin,eos,mock,assignor,conf\0" ;
pub const RD_KAFKA_DESTROY_F_NO_CONSUMER_CLOSE: u32 = 8;
pub const RD_KAFKA_OFFSET_BEGINNING: i32 = -2;
pub const RD_KAFKA_OFFSET_END: i32 = -1;
pub const RD_KAFKA_OFFSET_STORED: i32 = -1000;
pub const RD_KAFKA_OFFSET_INVALID: i32 = -1001;
pub const RD_KAFKA_OFFSET_TAIL_BASE: i32 = -2000;
pub const RD_KAFKA_MSG_F_FREE: u32 = 1;
pub const RD_KAFKA_MSG_F_COPY: u32 = 2;
pub const RD_KAFKA_MSG_F_BLOCK: u32 = 4;
pub const RD_KAFKA_MSG_F_PARTITION: u32 = 8;
pub const RD_KAFKA_PURGE_F_QUEUE: u32 = 1;
pub const RD_KAFKA_PURGE_F_INFLIGHT: u32 = 2;
pub const RD_KAFKA_PURGE_F_NON_BLOCKING: u32 = 4;
pub const RD_KAFKA_EVENT_NONE: u32 = 0;
pub const RD_KAFKA_EVENT_DR: u32 = 1;
pub const RD_KAFKA_EVENT_FETCH: u32 = 2;
pub const RD_KAFKA_EVENT_LOG: u32 = 4;
pub const RD_KAFKA_EVENT_ERROR: u32 = 8;
pub const RD_KAFKA_EVENT_REBALANCE: u32 = 16;
pub const RD_KAFKA_EVENT_OFFSET_COMMIT: u32 = 32;
pub const RD_KAFKA_EVENT_STATS: u32 = 64;
pub const RD_KAFKA_EVENT_CREATETOPICS_RESULT: u32 = 100;
pub const RD_KAFKA_EVENT_DELETETOPICS_RESULT: u32 = 101;
pub const RD_KAFKA_EVENT_CREATEPARTITIONS_RESULT: u32 = 102;
pub const RD_KAFKA_EVENT_ALTERCONFIGS_RESULT: u32 = 103;
pub const RD_KAFKA_EVENT_DESCRIBECONFIGS_RESULT: u32 = 104;
pub const RD_KAFKA_EVENT_DELETERECORDS_RESULT: u32 = 105;
pub const RD_KAFKA_EVENT_DELETEGROUPS_RESULT: u32 = 106;
pub const RD_KAFKA_EVENT_DELETECONSUMERGROUPOFFSETS_RESULT: u32 = 107;
pub const RD_KAFKA_EVENT_OAUTHBEARER_TOKEN_REFRESH: u32 = 256;
extern "C" {
    pub fn rd_kafka_version() -> c_int;
}
extern "C" {
    pub fn rd_kafka_version_str() -> *const c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_type_t {
    RD_KAFKA_PRODUCER = 0,
    RD_KAFKA_CONSUMER = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_timestamp_type_t {
    RD_KAFKA_TIMESTAMP_NOT_AVAILABLE = 0,
    RD_KAFKA_TIMESTAMP_CREATE_TIME = 1,
    RD_KAFKA_TIMESTAMP_LOG_APPEND_TIME = 2,
}
extern "C" {
    pub fn rd_kafka_get_debug_contexts() -> *const c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_s {
    _unused: [u8; 0],
}
pub type rd_kafka_t = rd_kafka_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_topic_s {
    _unused: [u8; 0],
}
pub type rd_kafka_topic_t = rd_kafka_topic_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_conf_s {
    _unused: [u8; 0],
}
pub type rd_kafka_conf_t = rd_kafka_conf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_topic_conf_s {
    _unused: [u8; 0],
}
pub type rd_kafka_topic_conf_t = rd_kafka_topic_conf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_queue_s {
    _unused: [u8; 0],
}
pub type rd_kafka_queue_t = rd_kafka_queue_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_op_s {
    _unused: [u8; 0],
}
pub type rd_kafka_event_t = rd_kafka_op_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_topic_result_s {
    _unused: [u8; 0],
}
pub type rd_kafka_topic_result_t = rd_kafka_topic_result_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_consumer_group_metadata_s {
    _unused: [u8; 0],
}
pub type rd_kafka_consumer_group_metadata_t = rd_kafka_consumer_group_metadata_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_error_s {
    _unused: [u8; 0],
}
pub type rd_kafka_error_t = rd_kafka_error_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_headers_s {
    _unused: [u8; 0],
}
pub type rd_kafka_headers_t = rd_kafka_headers_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_group_result_s {
    _unused: [u8; 0],
}
pub type rd_kafka_group_result_t = rd_kafka_group_result_s;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, TryFromPrimitive)]
pub enum rd_kafka_resp_err_t {
    RD_KAFKA_RESP_ERR__BEGIN = -200,
    RD_KAFKA_RESP_ERR__BAD_MSG = -199,
    RD_KAFKA_RESP_ERR__BAD_COMPRESSION = -198,
    RD_KAFKA_RESP_ERR__DESTROY = -197,
    RD_KAFKA_RESP_ERR__FAIL = -196,
    RD_KAFKA_RESP_ERR__TRANSPORT = -195,
    RD_KAFKA_RESP_ERR__CRIT_SYS_RESOURCE = -194,
    RD_KAFKA_RESP_ERR__RESOLVE = -193,
    RD_KAFKA_RESP_ERR__MSG_TIMED_OUT = -192,
    RD_KAFKA_RESP_ERR__PARTITION_EOF = -191,
    RD_KAFKA_RESP_ERR__UNKNOWN_PARTITION = -190,
    RD_KAFKA_RESP_ERR__FS = -189,
    RD_KAFKA_RESP_ERR__UNKNOWN_TOPIC = -188,
    RD_KAFKA_RESP_ERR__ALL_BROKERS_DOWN = -187,
    RD_KAFKA_RESP_ERR__INVALID_ARG = -186,
    RD_KAFKA_RESP_ERR__TIMED_OUT = -185,
    RD_KAFKA_RESP_ERR__QUEUE_FULL = -184,
    RD_KAFKA_RESP_ERR__ISR_INSUFF = -183,
    RD_KAFKA_RESP_ERR__NODE_UPDATE = -182,
    RD_KAFKA_RESP_ERR__SSL = -181,
    RD_KAFKA_RESP_ERR__WAIT_COORD = -180,
    RD_KAFKA_RESP_ERR__UNKNOWN_GROUP = -179,
    RD_KAFKA_RESP_ERR__IN_PROGRESS = -178,
    RD_KAFKA_RESP_ERR__PREV_IN_PROGRESS = -177,
    RD_KAFKA_RESP_ERR__EXISTING_SUBSCRIPTION = -176,
    RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS = -175,
    RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS = -174,
    RD_KAFKA_RESP_ERR__CONFLICT = -173,
    RD_KAFKA_RESP_ERR__STATE = -172,
    RD_KAFKA_RESP_ERR__UNKNOWN_PROTOCOL = -171,
    RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED = -170,
    RD_KAFKA_RESP_ERR__AUTHENTICATION = -169,
    RD_KAFKA_RESP_ERR__NO_OFFSET = -168,
    RD_KAFKA_RESP_ERR__OUTDATED = -167,
    RD_KAFKA_RESP_ERR__TIMED_OUT_QUEUE = -166,
    RD_KAFKA_RESP_ERR__UNSUPPORTED_FEATURE = -165,
    RD_KAFKA_RESP_ERR__WAIT_CACHE = -164,
    RD_KAFKA_RESP_ERR__INTR = -163,
    RD_KAFKA_RESP_ERR__KEY_SERIALIZATION = -162,
    RD_KAFKA_RESP_ERR__VALUE_SERIALIZATION = -161,
    RD_KAFKA_RESP_ERR__KEY_DESERIALIZATION = -160,
    RD_KAFKA_RESP_ERR__VALUE_DESERIALIZATION = -159,
    RD_KAFKA_RESP_ERR__PARTIAL = -158,
    RD_KAFKA_RESP_ERR__READ_ONLY = -157,
    RD_KAFKA_RESP_ERR__NOENT = -156,
    RD_KAFKA_RESP_ERR__UNDERFLOW = -155,
    RD_KAFKA_RESP_ERR__INVALID_TYPE = -154,
    RD_KAFKA_RESP_ERR__RETRY = -153,
    RD_KAFKA_RESP_ERR__PURGE_QUEUE = -152,
    RD_KAFKA_RESP_ERR__PURGE_INFLIGHT = -151,
    RD_KAFKA_RESP_ERR__FATAL = -150,
    RD_KAFKA_RESP_ERR__INCONSISTENT = -149,
    RD_KAFKA_RESP_ERR__GAPLESS_GUARANTEE = -148,
    RD_KAFKA_RESP_ERR__MAX_POLL_EXCEEDED = -147,
    RD_KAFKA_RESP_ERR__UNKNOWN_BROKER = -146,
    RD_KAFKA_RESP_ERR__NOT_CONFIGURED = -145,
    RD_KAFKA_RESP_ERR__FENCED = -144,
    RD_KAFKA_RESP_ERR__APPLICATION = -143,
    RD_KAFKA_RESP_ERR__ASSIGNMENT_LOST = -142,
    RD_KAFKA_RESP_ERR__NOOP = -141,
    RD_KAFKA_RESP_ERR__AUTO_OFFSET_RESET = -140,
    RD_KAFKA_RESP_ERR__END = -100,
    RD_KAFKA_RESP_ERR_UNKNOWN = -1,
    RD_KAFKA_RESP_ERR_NO_ERROR = 0,
    RD_KAFKA_RESP_ERR_OFFSET_OUT_OF_RANGE = 1,
    RD_KAFKA_RESP_ERR_INVALID_MSG = 2,
    RD_KAFKA_RESP_ERR_UNKNOWN_TOPIC_OR_PART = 3,
    RD_KAFKA_RESP_ERR_INVALID_MSG_SIZE = 4,
    RD_KAFKA_RESP_ERR_LEADER_NOT_AVAILABLE = 5,
    RD_KAFKA_RESP_ERR_NOT_LEADER_FOR_PARTITION = 6,
    RD_KAFKA_RESP_ERR_REQUEST_TIMED_OUT = 7,
    RD_KAFKA_RESP_ERR_BROKER_NOT_AVAILABLE = 8,
    RD_KAFKA_RESP_ERR_REPLICA_NOT_AVAILABLE = 9,
    RD_KAFKA_RESP_ERR_MSG_SIZE_TOO_LARGE = 10,
    RD_KAFKA_RESP_ERR_STALE_CTRL_EPOCH = 11,
    RD_KAFKA_RESP_ERR_OFFSET_METADATA_TOO_LARGE = 12,
    RD_KAFKA_RESP_ERR_NETWORK_EXCEPTION = 13,
    RD_KAFKA_RESP_ERR_COORDINATOR_LOAD_IN_PROGRESS = 14,
    RD_KAFKA_RESP_ERR_COORDINATOR_NOT_AVAILABLE = 15,
    RD_KAFKA_RESP_ERR_NOT_COORDINATOR = 16,
    RD_KAFKA_RESP_ERR_TOPIC_EXCEPTION = 17,
    RD_KAFKA_RESP_ERR_RECORD_LIST_TOO_LARGE = 18,
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS = 19,
    RD_KAFKA_RESP_ERR_NOT_ENOUGH_REPLICAS_AFTER_APPEND = 20,
    RD_KAFKA_RESP_ERR_INVALID_REQUIRED_ACKS = 21,
    RD_KAFKA_RESP_ERR_ILLEGAL_GENERATION = 22,
    RD_KAFKA_RESP_ERR_INCONSISTENT_GROUP_PROTOCOL = 23,
    RD_KAFKA_RESP_ERR_INVALID_GROUP_ID = 24,
    RD_KAFKA_RESP_ERR_UNKNOWN_MEMBER_ID = 25,
    RD_KAFKA_RESP_ERR_INVALID_SESSION_TIMEOUT = 26,
    RD_KAFKA_RESP_ERR_REBALANCE_IN_PROGRESS = 27,
    RD_KAFKA_RESP_ERR_INVALID_COMMIT_OFFSET_SIZE = 28,
    RD_KAFKA_RESP_ERR_TOPIC_AUTHORIZATION_FAILED = 29,
    RD_KAFKA_RESP_ERR_GROUP_AUTHORIZATION_FAILED = 30,
    RD_KAFKA_RESP_ERR_CLUSTER_AUTHORIZATION_FAILED = 31,
    RD_KAFKA_RESP_ERR_INVALID_TIMESTAMP = 32,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_SASL_MECHANISM = 33,
    RD_KAFKA_RESP_ERR_ILLEGAL_SASL_STATE = 34,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_VERSION = 35,
    RD_KAFKA_RESP_ERR_TOPIC_ALREADY_EXISTS = 36,
    RD_KAFKA_RESP_ERR_INVALID_PARTITIONS = 37,
    RD_KAFKA_RESP_ERR_INVALID_REPLICATION_FACTOR = 38,
    RD_KAFKA_RESP_ERR_INVALID_REPLICA_ASSIGNMENT = 39,
    RD_KAFKA_RESP_ERR_INVALID_CONFIG = 40,
    RD_KAFKA_RESP_ERR_NOT_CONTROLLER = 41,
    RD_KAFKA_RESP_ERR_INVALID_REQUEST = 42,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_FOR_MESSAGE_FORMAT = 43,
    RD_KAFKA_RESP_ERR_POLICY_VIOLATION = 44,
    RD_KAFKA_RESP_ERR_OUT_OF_ORDER_SEQUENCE_NUMBER = 45,
    RD_KAFKA_RESP_ERR_DUPLICATE_SEQUENCE_NUMBER = 46,
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_EPOCH = 47,
    RD_KAFKA_RESP_ERR_INVALID_TXN_STATE = 48,
    RD_KAFKA_RESP_ERR_INVALID_PRODUCER_ID_MAPPING = 49,
    RD_KAFKA_RESP_ERR_INVALID_TRANSACTION_TIMEOUT = 50,
    RD_KAFKA_RESP_ERR_CONCURRENT_TRANSACTIONS = 51,
    RD_KAFKA_RESP_ERR_TRANSACTION_COORDINATOR_FENCED = 52,
    RD_KAFKA_RESP_ERR_TRANSACTIONAL_ID_AUTHORIZATION_FAILED = 53,
    RD_KAFKA_RESP_ERR_SECURITY_DISABLED = 54,
    RD_KAFKA_RESP_ERR_OPERATION_NOT_ATTEMPTED = 55,
    RD_KAFKA_RESP_ERR_KAFKA_STORAGE_ERROR = 56,
    RD_KAFKA_RESP_ERR_LOG_DIR_NOT_FOUND = 57,
    RD_KAFKA_RESP_ERR_SASL_AUTHENTICATION_FAILED = 58,
    RD_KAFKA_RESP_ERR_UNKNOWN_PRODUCER_ID = 59,
    RD_KAFKA_RESP_ERR_REASSIGNMENT_IN_PROGRESS = 60,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTH_DISABLED = 61,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_NOT_FOUND = 62,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_OWNER_MISMATCH = 63,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_REQUEST_NOT_ALLOWED = 64,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_AUTHORIZATION_FAILED = 65,
    RD_KAFKA_RESP_ERR_DELEGATION_TOKEN_EXPIRED = 66,
    RD_KAFKA_RESP_ERR_INVALID_PRINCIPAL_TYPE = 67,
    RD_KAFKA_RESP_ERR_NON_EMPTY_GROUP = 68,
    RD_KAFKA_RESP_ERR_GROUP_ID_NOT_FOUND = 69,
    RD_KAFKA_RESP_ERR_FETCH_SESSION_ID_NOT_FOUND = 70,
    RD_KAFKA_RESP_ERR_INVALID_FETCH_SESSION_EPOCH = 71,
    RD_KAFKA_RESP_ERR_LISTENER_NOT_FOUND = 72,
    RD_KAFKA_RESP_ERR_TOPIC_DELETION_DISABLED = 73,
    RD_KAFKA_RESP_ERR_FENCED_LEADER_EPOCH = 74,
    RD_KAFKA_RESP_ERR_UNKNOWN_LEADER_EPOCH = 75,
    RD_KAFKA_RESP_ERR_UNSUPPORTED_COMPRESSION_TYPE = 76,
    RD_KAFKA_RESP_ERR_STALE_BROKER_EPOCH = 77,
    RD_KAFKA_RESP_ERR_OFFSET_NOT_AVAILABLE = 78,
    RD_KAFKA_RESP_ERR_MEMBER_ID_REQUIRED = 79,
    RD_KAFKA_RESP_ERR_PREFERRED_LEADER_NOT_AVAILABLE = 80,
    RD_KAFKA_RESP_ERR_GROUP_MAX_SIZE_REACHED = 81,
    RD_KAFKA_RESP_ERR_FENCED_INSTANCE_ID = 82,
    RD_KAFKA_RESP_ERR_ELIGIBLE_LEADERS_NOT_AVAILABLE = 83,
    RD_KAFKA_RESP_ERR_ELECTION_NOT_NEEDED = 84,
    RD_KAFKA_RESP_ERR_NO_REASSIGNMENT_IN_PROGRESS = 85,
    RD_KAFKA_RESP_ERR_GROUP_SUBSCRIBED_TO_TOPIC = 86,
    RD_KAFKA_RESP_ERR_INVALID_RECORD = 87,
    RD_KAFKA_RESP_ERR_UNSTABLE_OFFSET_COMMIT = 88,
    RD_KAFKA_RESP_ERR_THROTTLING_QUOTA_EXCEEDED = 89,
    RD_KAFKA_RESP_ERR_PRODUCER_FENCED = 90,
    RD_KAFKA_RESP_ERR_RESOURCE_NOT_FOUND = 91,
    RD_KAFKA_RESP_ERR_DUPLICATE_RESOURCE = 92,
    RD_KAFKA_RESP_ERR_UNACCEPTABLE_CREDENTIAL = 93,
    RD_KAFKA_RESP_ERR_INCONSISTENT_VOTER_SET = 94,
    RD_KAFKA_RESP_ERR_INVALID_UPDATE_VERSION = 95,
    RD_KAFKA_RESP_ERR_FEATURE_UPDATE_FAILED = 96,
    RD_KAFKA_RESP_ERR_PRINCIPAL_DESERIALIZATION_FAILURE = 97,
    RD_KAFKA_RESP_ERR_END_ALL = 98,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_err_desc {
    pub code: rd_kafka_resp_err_t,
    pub name: *const c_char,
    pub desc: *const c_char,
}
extern "C" {
    pub fn rd_kafka_get_err_descs(errdescs: *mut *const rd_kafka_err_desc, cntp: *mut size_t);
}
extern "C" {
    pub fn rd_kafka_err2str(err: rd_kafka_resp_err_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_err2name(err: rd_kafka_resp_err_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_last_error() -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_errno2err(errnox: c_int) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_errno() -> c_int;
}
extern "C" {
    pub fn rd_kafka_fatal_error(
        rk: *mut rd_kafka_t,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_test_fatal_error(
        rk: *mut rd_kafka_t,
        err: rd_kafka_resp_err_t,
        reason: *const c_char,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_error_code(error: *const rd_kafka_error_t) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_error_name(error: *const rd_kafka_error_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_error_string(error: *const rd_kafka_error_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_error_is_fatal(error: *const rd_kafka_error_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_error_is_retriable(error: *const rd_kafka_error_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_error_txn_requires_abort(error: *const rd_kafka_error_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_error_destroy(error: *mut rd_kafka_error_t);
}
extern "C" {
    pub fn rd_kafka_error_new(
        code: rd_kafka_resp_err_t,
        fmt: *const c_char,
        ...
    ) -> *mut rd_kafka_error_t;
}
#[repr(C)]
pub struct rd_kafka_topic_partition_s {
    pub topic: *mut c_char,
    pub partition: i32,
    pub offset: i64,
    pub metadata: *mut c_void,
    pub metadata_size: size_t,
    pub opaque: *mut c_void,
    pub err: rd_kafka_resp_err_t,
    pub _private: *mut c_void,
}
pub type rd_kafka_topic_partition_t = rd_kafka_topic_partition_s;
extern "C" {
    pub fn rd_kafka_topic_partition_destroy(rktpar: *mut rd_kafka_topic_partition_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_topic_partition_list_s {
    pub cnt: c_int,
    pub size: c_int,
    pub elems: *mut rd_kafka_topic_partition_t,
}
pub type rd_kafka_topic_partition_list_t = rd_kafka_topic_partition_list_s;
extern "C" {
    pub fn rd_kafka_topic_partition_list_new(size: c_int) -> *mut rd_kafka_topic_partition_list_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_destroy(rkparlist: *mut rd_kafka_topic_partition_list_t);
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_add(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const c_char,
        partition: i32,
    ) -> *mut rd_kafka_topic_partition_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_add_range(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const c_char,
        start: i32,
        stop: i32,
    );
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_del(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const c_char,
        partition: i32,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_del_by_idx(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        idx: c_int,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_copy(
        src: *const rd_kafka_topic_partition_list_t,
    ) -> *mut rd_kafka_topic_partition_list_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_set_offset(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        topic: *const c_char,
        partition: i32,
        offset: i64,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_find(
        rktparlist: *const rd_kafka_topic_partition_list_t,
        topic: *const c_char,
        partition: i32,
    ) -> *mut rd_kafka_topic_partition_t;
}
extern "C" {
    pub fn rd_kafka_topic_partition_list_sort(
        rktparlist: *mut rd_kafka_topic_partition_list_t,
        cmp: Option<
            unsafe extern "C" fn(
                a: *const c_void,
                b: *const c_void,
                cmp_opaque: *mut c_void,
            ) -> c_int,
        >,
        cmp_opaque: *mut c_void,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_vtype_t {
    RD_KAFKA_VTYPE_END = 0,
    RD_KAFKA_VTYPE_TOPIC = 1,
    RD_KAFKA_VTYPE_RKT = 2,
    RD_KAFKA_VTYPE_PARTITION = 3,
    RD_KAFKA_VTYPE_VALUE = 4,
    RD_KAFKA_VTYPE_KEY = 5,
    RD_KAFKA_VTYPE_OPAQUE = 6,
    RD_KAFKA_VTYPE_MSGFLAGS = 7,
    RD_KAFKA_VTYPE_TIMESTAMP = 8,
    RD_KAFKA_VTYPE_HEADER = 9,
    RD_KAFKA_VTYPE_HEADERS = 10,
}
#[repr(C)]
pub struct rd_kafka_vu_s {
    pub vtype: rd_kafka_vtype_t,
    pub u: rd_kafka_vu_s__bindgen_ty_1,
}
#[repr(C)]
pub struct rd_kafka_vu_s__bindgen_ty_1 {
    pub cstr: __BindgenUnionField<*const c_char>,
    pub rkt: __BindgenUnionField<*mut rd_kafka_topic_t>,
    pub i: __BindgenUnionField<c_int>,
    pub i32_: __BindgenUnionField<i32>,
    pub i64_: __BindgenUnionField<i64>,
    pub mem: __BindgenUnionField<rd_kafka_vu_s__bindgen_ty_1__bindgen_ty_1>,
    pub header: __BindgenUnionField<rd_kafka_vu_s__bindgen_ty_1__bindgen_ty_2>,
    pub headers: __BindgenUnionField<*mut rd_kafka_headers_t>,
    pub ptr: __BindgenUnionField<*mut c_void>,
    pub _pad: __BindgenUnionField<[c_char; 64usize]>,
    pub bindgen_union_field: [u64; 8usize],
}
#[repr(C)]
pub struct rd_kafka_vu_s__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *mut c_void,
    pub size: size_t,
}
#[repr(C)]
pub struct rd_kafka_vu_s__bindgen_ty_1__bindgen_ty_2 {
    pub name: *const c_char,
    pub val: *const c_void,
    pub size: ssize_t,
}
pub type rd_kafka_vu_t = rd_kafka_vu_s;
extern "C" {
    pub fn rd_kafka_headers_new(initial_count: size_t) -> *mut rd_kafka_headers_t;
}
extern "C" {
    pub fn rd_kafka_headers_destroy(hdrs: *mut rd_kafka_headers_t);
}
extern "C" {
    pub fn rd_kafka_headers_copy(src: *const rd_kafka_headers_t) -> *mut rd_kafka_headers_t;
}
extern "C" {
    pub fn rd_kafka_header_add(
        hdrs: *mut rd_kafka_headers_t,
        name: *const c_char,
        name_size: ssize_t,
        value: *const c_void,
        value_size: ssize_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_header_remove(
        hdrs: *mut rd_kafka_headers_t,
        name: *const c_char,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_header_get_last(
        hdrs: *const rd_kafka_headers_t,
        name: *const c_char,
        valuep: *mut *const c_void,
        sizep: *mut size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_header_get(
        hdrs: *const rd_kafka_headers_t,
        idx: size_t,
        name: *const c_char,
        valuep: *mut *const c_void,
        sizep: *mut size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_header_get_all(
        hdrs: *const rd_kafka_headers_t,
        idx: size_t,
        namep: *mut *const c_char,
        valuep: *mut *const c_void,
        sizep: *mut size_t,
    ) -> rd_kafka_resp_err_t;
}
#[repr(C)]
pub struct rd_kafka_message_s {
    pub err: rd_kafka_resp_err_t,
    pub rkt: *mut rd_kafka_topic_t,
    pub partition: i32,
    pub payload: *mut c_void,
    pub len: size_t,
    pub key: *mut c_void,
    pub key_len: size_t,
    pub offset: i64,
    pub _private: *mut c_void,
}
pub type rd_kafka_message_t = rd_kafka_message_s;
extern "C" {
    pub fn rd_kafka_message_destroy(rkmessage: *mut rd_kafka_message_t);
}
extern "C" {
    pub fn rd_kafka_message_errstr(rkmessage: *const rd_kafka_message_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_message_timestamp(
        rkmessage: *const rd_kafka_message_t,
        tstype: *mut rd_kafka_timestamp_type_t,
    ) -> i64;
}
extern "C" {
    pub fn rd_kafka_message_latency(rkmessage: *const rd_kafka_message_t) -> i64;
}
extern "C" {
    pub fn rd_kafka_message_broker_id(rkmessage: *const rd_kafka_message_t) -> i32;
}
extern "C" {
    pub fn rd_kafka_message_headers(
        rkmessage: *const rd_kafka_message_t,
        hdrsp: *mut *mut rd_kafka_headers_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_message_detach_headers(
        rkmessage: *mut rd_kafka_message_t,
        hdrsp: *mut *mut rd_kafka_headers_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_message_set_headers(
        rkmessage: *mut rd_kafka_message_t,
        hdrs: *mut rd_kafka_headers_t,
    );
}
extern "C" {
    pub fn rd_kafka_header_cnt(hdrs: *const rd_kafka_headers_t) -> size_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_msg_status_t {
    RD_KAFKA_MSG_STATUS_NOT_PERSISTED = 0,
    RD_KAFKA_MSG_STATUS_POSSIBLY_PERSISTED = 1,
    RD_KAFKA_MSG_STATUS_PERSISTED = 2,
}
extern "C" {
    pub fn rd_kafka_message_status(rkmessage: *const rd_kafka_message_t) -> rd_kafka_msg_status_t;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_conf_res_t {
    RD_KAFKA_CONF_UNKNOWN = -2,
    RD_KAFKA_CONF_INVALID = -1,
    RD_KAFKA_CONF_OK = 0,
}
extern "C" {
    pub fn rd_kafka_conf_new() -> *mut rd_kafka_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf_destroy(conf: *mut rd_kafka_conf_t);
}
extern "C" {
    pub fn rd_kafka_conf_dup(conf: *const rd_kafka_conf_t) -> *mut rd_kafka_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf_dup_filter(
        conf: *const rd_kafka_conf_t,
        filter_cnt: size_t,
        filter: *mut *const c_char,
    ) -> *mut rd_kafka_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf(rk: *mut rd_kafka_t) -> *const rd_kafka_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf_set(
        conf: *mut rd_kafka_conf_t,
        name: *const c_char,
        value: *const c_char,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_conf_set_events(conf: *mut rd_kafka_conf_t, events: c_int);
}
extern "C" {
    pub fn rd_kafka_conf_set_background_event_cb(
        conf: *mut rd_kafka_conf_t,
        event_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                rkev: *mut rd_kafka_event_t,
                opaque: *mut c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_dr_cb(
        conf: *mut rd_kafka_conf_t,
        dr_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                payload: *mut c_void,
                len: size_t,
                err: rd_kafka_resp_err_t,
                opaque: *mut c_void,
                msg_opaque: *mut c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_dr_msg_cb(
        conf: *mut rd_kafka_conf_t,
        dr_msg_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                rkmessage: *const rd_kafka_message_t,
                opaque: *mut c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_consume_cb(
        conf: *mut rd_kafka_conf_t,
        consume_cb: Option<
            unsafe extern "C" fn(rkmessage: *mut rd_kafka_message_t, opaque: *mut c_void),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_rebalance_cb(
        conf: *mut rd_kafka_conf_t,
        rebalance_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                err: rd_kafka_resp_err_t,
                partitions: *mut rd_kafka_topic_partition_list_t,
                opaque: *mut c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_offset_commit_cb(
        conf: *mut rd_kafka_conf_t,
        offset_commit_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                err: rd_kafka_resp_err_t,
                offsets: *mut rd_kafka_topic_partition_list_t,
                opaque: *mut c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_error_cb(
        conf: *mut rd_kafka_conf_t,
        error_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                err: c_int,
                reason: *const c_char,
                opaque: *mut c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_throttle_cb(
        conf: *mut rd_kafka_conf_t,
        throttle_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                broker_name: *const c_char,
                broker_id: i32,
                throttle_time_ms: c_int,
                opaque: *mut c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_log_cb(
        conf: *mut rd_kafka_conf_t,
        log_cb: Option<
            unsafe extern "C" fn(
                rk: *const rd_kafka_t,
                level: c_int,
                fac: *const c_char,
                buf: *const c_char,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_stats_cb(
        conf: *mut rd_kafka_conf_t,
        stats_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                json: *mut c_char,
                json_len: size_t,
                opaque: *mut c_void,
            ) -> c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_oauthbearer_token_refresh_cb(
        conf: *mut rd_kafka_conf_t,
        oauthbearer_token_refresh_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                oauthbearer_config: *const c_char,
                opaque: *mut c_void,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_socket_cb(
        conf: *mut rd_kafka_conf_t,
        socket_cb: Option<
            unsafe extern "C" fn(
                domain: c_int,
                type_: c_int,
                protocol: c_int,
                opaque: *mut c_void,
            ) -> c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_connect_cb(
        conf: *mut rd_kafka_conf_t,
        connect_cb: Option<
            unsafe extern "C" fn(
                sockfd: c_int,
                addr: *const sockaddr,
                addrlen: c_int,
                id: *const c_char,
                opaque: *mut c_void,
            ) -> c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_closesocket_cb(
        conf: *mut rd_kafka_conf_t,
        closesocket_cb: Option<unsafe extern "C" fn(sockfd: c_int, opaque: *mut c_void) -> c_int>,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_ssl_cert_verify_cb(
        conf: *mut rd_kafka_conf_t,
        ssl_cert_verify_cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                broker_name: *const c_char,
                broker_id: i32,
                x509_error: *mut c_int,
                depth: c_int,
                buf: *const c_char,
                size: size_t,
                errstr: *mut c_char,
                errstr_size: size_t,
                opaque: *mut c_void,
            ) -> c_int,
        >,
    ) -> rd_kafka_conf_res_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_cert_type_t {
    RD_KAFKA_CERT_PUBLIC_KEY = 0,
    RD_KAFKA_CERT_PRIVATE_KEY = 1,
    RD_KAFKA_CERT_CA = 2,
    RD_KAFKA_CERT__CNT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_cert_enc_t {
    RD_KAFKA_CERT_ENC_PKCS12 = 0,
    RD_KAFKA_CERT_ENC_DER = 1,
    RD_KAFKA_CERT_ENC_PEM = 2,
    RD_KAFKA_CERT_ENC__CNT = 3,
}
extern "C" {
    pub fn rd_kafka_conf_set_ssl_cert(
        conf: *mut rd_kafka_conf_t,
        cert_type: rd_kafka_cert_type_t,
        cert_enc: rd_kafka_cert_enc_t,
        buffer: *const c_void,
        size: size_t,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_conf_set_engine_callback_data(
        conf: *mut rd_kafka_conf_t,
        callback_data: *mut c_void,
    );
}
extern "C" {
    pub fn rd_kafka_conf_set_opaque(conf: *mut rd_kafka_conf_t, opaque: *mut c_void);
}
extern "C" {
    pub fn rd_kafka_opaque(rk: *const rd_kafka_t) -> *mut c_void;
}
extern "C" {
    pub fn rd_kafka_conf_set_default_topic_conf(
        conf: *mut rd_kafka_conf_t,
        tconf: *mut rd_kafka_topic_conf_t,
    );
}
extern "C" {
    pub fn rd_kafka_conf_get_default_topic_conf(
        conf: *mut rd_kafka_conf_t,
    ) -> *mut rd_kafka_topic_conf_t;
}
extern "C" {
    pub fn rd_kafka_conf_get(
        conf: *const rd_kafka_conf_t,
        name: *const c_char,
        dest: *mut c_char,
        dest_size: *mut size_t,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_topic_conf_get(
        conf: *const rd_kafka_topic_conf_t,
        name: *const c_char,
        dest: *mut c_char,
        dest_size: *mut size_t,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_conf_dump(conf: *mut rd_kafka_conf_t, cntp: *mut size_t) -> *mut *const c_char;
}
extern "C" {
    pub fn rd_kafka_topic_conf_dump(
        conf: *mut rd_kafka_topic_conf_t,
        cntp: *mut size_t,
    ) -> *mut *const c_char;
}
extern "C" {
    pub fn rd_kafka_conf_dump_free(arr: *mut *const c_char, cnt: size_t);
}
extern "C" {
    pub fn rd_kafka_conf_properties_show(fp: *mut FILE);
}
extern "C" {
    pub fn rd_kafka_topic_conf_new() -> *mut rd_kafka_topic_conf_t;
}
extern "C" {
    pub fn rd_kafka_topic_conf_dup(
        conf: *const rd_kafka_topic_conf_t,
    ) -> *mut rd_kafka_topic_conf_t;
}
extern "C" {
    pub fn rd_kafka_default_topic_conf_dup(rk: *mut rd_kafka_t) -> *mut rd_kafka_topic_conf_t;
}
extern "C" {
    pub fn rd_kafka_topic_conf_destroy(topic_conf: *mut rd_kafka_topic_conf_t);
}
extern "C" {
    pub fn rd_kafka_topic_conf_set(
        conf: *mut rd_kafka_topic_conf_t,
        name: *const c_char,
        value: *const c_char,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_conf_res_t;
}
extern "C" {
    pub fn rd_kafka_topic_conf_set_opaque(
        conf: *mut rd_kafka_topic_conf_t,
        rkt_opaque: *mut c_void,
    );
}
extern "C" {
    pub fn rd_kafka_topic_conf_set_partitioner_cb(
        topic_conf: *mut rd_kafka_topic_conf_t,
        partitioner: Option<
            unsafe extern "C" fn(
                rkt: *const rd_kafka_topic_t,
                keydata: *const c_void,
                keylen: size_t,
                partition_cnt: i32,
                rkt_opaque: *mut c_void,
                msg_opaque: *mut c_void,
            ) -> i32,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_topic_conf_set_msg_order_cmp(
        topic_conf: *mut rd_kafka_topic_conf_t,
        msg_order_cmp: Option<
            unsafe extern "C" fn(
                a: *const rd_kafka_message_t,
                b: *const rd_kafka_message_t,
            ) -> c_int,
        >,
    );
}
extern "C" {
    pub fn rd_kafka_topic_partition_available(
        rkt: *const rd_kafka_topic_t,
        partition: i32,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_random(
        rkt: *const rd_kafka_topic_t,
        key: *const c_void,
        keylen: size_t,
        partition_cnt: i32,
        rkt_opaque: *mut c_void,
        msg_opaque: *mut c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_consistent(
        rkt: *const rd_kafka_topic_t,
        key: *const c_void,
        keylen: size_t,
        partition_cnt: i32,
        rkt_opaque: *mut c_void,
        msg_opaque: *mut c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_consistent_random(
        rkt: *const rd_kafka_topic_t,
        key: *const c_void,
        keylen: size_t,
        partition_cnt: i32,
        rkt_opaque: *mut c_void,
        msg_opaque: *mut c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_murmur2(
        rkt: *const rd_kafka_topic_t,
        key: *const c_void,
        keylen: size_t,
        partition_cnt: i32,
        rkt_opaque: *mut c_void,
        msg_opaque: *mut c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_murmur2_random(
        rkt: *const rd_kafka_topic_t,
        key: *const c_void,
        keylen: size_t,
        partition_cnt: i32,
        rkt_opaque: *mut c_void,
        msg_opaque: *mut c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_fnv1a(
        rkt: *const rd_kafka_topic_t,
        key: *const c_void,
        keylen: size_t,
        partition_cnt: i32,
        rkt_opaque: *mut c_void,
        msg_opaque: *mut c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_msg_partitioner_fnv1a_random(
        rkt: *const rd_kafka_topic_t,
        key: *const c_void,
        keylen: size_t,
        partition_cnt: i32,
        rkt_opaque: *mut c_void,
        msg_opaque: *mut c_void,
    ) -> i32;
}
extern "C" {
    pub fn rd_kafka_new(
        type_: rd_kafka_type_t,
        conf: *mut rd_kafka_conf_t,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> *mut rd_kafka_t;
}
extern "C" {
    pub fn rd_kafka_destroy(rk: *mut rd_kafka_t);
}
extern "C" {
    pub fn rd_kafka_destroy_flags(rk: *mut rd_kafka_t, flags: c_int);
}
extern "C" {
    pub fn rd_kafka_name(rk: *const rd_kafka_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_type(rk: *const rd_kafka_t) -> rd_kafka_type_t;
}
extern "C" {
    pub fn rd_kafka_memberid(rk: *const rd_kafka_t) -> *mut c_char;
}
extern "C" {
    pub fn rd_kafka_clusterid(rk: *mut rd_kafka_t, timeout_ms: c_int) -> *mut c_char;
}
extern "C" {
    pub fn rd_kafka_controllerid(rk: *mut rd_kafka_t, timeout_ms: c_int) -> i32;
}
extern "C" {
    pub fn rd_kafka_topic_new(
        rk: *mut rd_kafka_t,
        topic: *const c_char,
        conf: *mut rd_kafka_topic_conf_t,
    ) -> *mut rd_kafka_topic_t;
}
extern "C" {
    pub fn rd_kafka_topic_destroy(rkt: *mut rd_kafka_topic_t);
}
extern "C" {
    pub fn rd_kafka_topic_name(rkt: *const rd_kafka_topic_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_topic_opaque(rkt: *const rd_kafka_topic_t) -> *mut c_void;
}
extern "C" {
    pub fn rd_kafka_poll(rk: *mut rd_kafka_t, timeout_ms: c_int) -> c_int;
}
extern "C" {
    pub fn rd_kafka_yield(rk: *mut rd_kafka_t);
}
extern "C" {
    pub fn rd_kafka_pause_partitions(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_resume_partitions(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_query_watermark_offsets(
        rk: *mut rd_kafka_t,
        topic: *const c_char,
        partition: i32,
        low: *mut i64,
        high: *mut i64,
        timeout_ms: c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_get_watermark_offsets(
        rk: *mut rd_kafka_t,
        topic: *const c_char,
        partition: i32,
        low: *mut i64,
        high: *mut i64,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_offsets_for_times(
        rk: *mut rd_kafka_t,
        offsets: *mut rd_kafka_topic_partition_list_t,
        timeout_ms: c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_mem_calloc(rk: *mut rd_kafka_t, num: size_t, size: size_t) -> *mut c_void;
}
extern "C" {
    pub fn rd_kafka_mem_malloc(rk: *mut rd_kafka_t, size: size_t) -> *mut c_void;
}
extern "C" {
    pub fn rd_kafka_mem_free(rk: *mut rd_kafka_t, ptr: *mut c_void);
}
extern "C" {
    pub fn rd_kafka_queue_new(rk: *mut rd_kafka_t) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_destroy(rkqu: *mut rd_kafka_queue_t);
}
extern "C" {
    pub fn rd_kafka_queue_get_main(rk: *mut rd_kafka_t) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_get_consumer(rk: *mut rd_kafka_t) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_get_partition(
        rk: *mut rd_kafka_t,
        topic: *const c_char,
        partition: i32,
    ) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_get_background(rk: *mut rd_kafka_t) -> *mut rd_kafka_queue_t;
}
extern "C" {
    pub fn rd_kafka_queue_forward(src: *mut rd_kafka_queue_t, dst: *mut rd_kafka_queue_t);
}
extern "C" {
    pub fn rd_kafka_set_log_queue(
        rk: *mut rd_kafka_t,
        rkqu: *mut rd_kafka_queue_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_queue_length(rkqu: *mut rd_kafka_queue_t) -> size_t;
}
extern "C" {
    pub fn rd_kafka_queue_io_event_enable(
        rkqu: *mut rd_kafka_queue_t,
        fd: c_int,
        payload: *const c_void,
        size: size_t,
    );
}
extern "C" {
    pub fn rd_kafka_queue_cb_event_enable(
        rkqu: *mut rd_kafka_queue_t,
        event_cb: Option<unsafe extern "C" fn(rk: *mut rd_kafka_t, qev_opaque: *mut c_void)>,
        qev_opaque: *mut c_void,
    );
}
extern "C" {
    pub fn rd_kafka_queue_yield(rkqu: *mut rd_kafka_queue_t);
}
extern "C" {
    pub fn rd_kafka_consume_start(rkt: *mut rd_kafka_topic_t, partition: i32, offset: i64)
        -> c_int;
}
extern "C" {
    pub fn rd_kafka_consume_start_queue(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        offset: i64,
        rkqu: *mut rd_kafka_queue_t,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_consume_stop(rkt: *mut rd_kafka_topic_t, partition: i32) -> c_int;
}
extern "C" {
    pub fn rd_kafka_seek(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        offset: i64,
        timeout_ms: c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_seek_partitions(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_consume(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_message_t;
}
extern "C" {
    pub fn rd_kafka_consume_batch(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        timeout_ms: c_int,
        rkmessages: *mut *mut rd_kafka_message_t,
        rkmessages_size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rd_kafka_consume_callback(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        timeout_ms: c_int,
        consume_cb: Option<
            unsafe extern "C" fn(rkmessage: *mut rd_kafka_message_t, commit_opaque: *mut c_void),
        >,
        commit_opaque: *mut c_void,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_consume_queue(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_message_t;
}
extern "C" {
    pub fn rd_kafka_consume_batch_queue(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: c_int,
        rkmessages: *mut *mut rd_kafka_message_t,
        rkmessages_size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rd_kafka_consume_callback_queue(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: c_int,
        consume_cb: Option<
            unsafe extern "C" fn(rkmessage: *mut rd_kafka_message_t, commit_opaque: *mut c_void),
        >,
        commit_opaque: *mut c_void,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_offset_store(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        offset: i64,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_offsets_store(
        rk: *mut rd_kafka_t,
        offsets: *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_subscribe(
        rk: *mut rd_kafka_t,
        topics: *const rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_unsubscribe(rk: *mut rd_kafka_t) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_subscription(
        rk: *mut rd_kafka_t,
        topics: *mut *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_consumer_poll(
        rk: *mut rd_kafka_t,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_message_t;
}
extern "C" {
    pub fn rd_kafka_consumer_close(rk: *mut rd_kafka_t) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_incremental_assign(
        rk: *mut rd_kafka_t,
        partitions: *const rd_kafka_topic_partition_list_t,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_incremental_unassign(
        rk: *mut rd_kafka_t,
        partitions: *const rd_kafka_topic_partition_list_t,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_rebalance_protocol(rk: *mut rd_kafka_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_assign(
        rk: *mut rd_kafka_t,
        partitions: *const rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_assignment(
        rk: *mut rd_kafka_t,
        partitions: *mut *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_assignment_lost(rk: *mut rd_kafka_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_commit(
        rk: *mut rd_kafka_t,
        offsets: *const rd_kafka_topic_partition_list_t,
        async_: c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_commit_message(
        rk: *mut rd_kafka_t,
        rkmessage: *const rd_kafka_message_t,
        async_: c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_commit_queue(
        rk: *mut rd_kafka_t,
        offsets: *const rd_kafka_topic_partition_list_t,
        rkqu: *mut rd_kafka_queue_t,
        cb: Option<
            unsafe extern "C" fn(
                rk: *mut rd_kafka_t,
                err: rd_kafka_resp_err_t,
                offsets: *mut rd_kafka_topic_partition_list_t,
                commit_opaque: *mut c_void,
            ),
        >,
        commit_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_committed(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
        timeout_ms: c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_position(
        rk: *mut rd_kafka_t,
        partitions: *mut rd_kafka_topic_partition_list_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_consumer_group_metadata(
        rk: *mut rd_kafka_t,
    ) -> *mut rd_kafka_consumer_group_metadata_t;
}
extern "C" {
    pub fn rd_kafka_consumer_group_metadata_new(
        group_id: *const c_char,
    ) -> *mut rd_kafka_consumer_group_metadata_t;
}
extern "C" {
    pub fn rd_kafka_consumer_group_metadata_new_with_genid(
        group_id: *const c_char,
        generation_id: i32,
        member_id: *const c_char,
        group_instance_id: *const c_char,
    ) -> *mut rd_kafka_consumer_group_metadata_t;
}
extern "C" {
    pub fn rd_kafka_consumer_group_metadata_destroy(arg1: *mut rd_kafka_consumer_group_metadata_t);
}
extern "C" {
    pub fn rd_kafka_consumer_group_metadata_write(
        cgmd: *const rd_kafka_consumer_group_metadata_t,
        bufferp: *mut *mut c_void,
        sizep: *mut size_t,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_consumer_group_metadata_read(
        cgmdp: *mut *mut rd_kafka_consumer_group_metadata_t,
        buffer: *const c_void,
        size: size_t,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_produce(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        msgflags: c_int,
        payload: *mut c_void,
        len: size_t,
        key: *const c_void,
        keylen: size_t,
        msg_opaque: *mut c_void,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_producev(rk: *mut rd_kafka_t, ...) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_produceva(
        rk: *mut rd_kafka_t,
        vus: *const rd_kafka_vu_t,
        cnt: size_t,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_produce_batch(
        rkt: *mut rd_kafka_topic_t,
        partition: i32,
        msgflags: c_int,
        rkmessages: *mut rd_kafka_message_t,
        message_cnt: c_int,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_flush(rk: *mut rd_kafka_t, timeout_ms: c_int) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_purge(rk: *mut rd_kafka_t, purge_flags: c_int) -> rd_kafka_resp_err_t;
}
#[repr(C)]
pub struct rd_kafka_metadata_broker {
    pub id: i32,
    pub host: *mut c_char,
    pub port: c_int,
}
pub type rd_kafka_metadata_broker_t = rd_kafka_metadata_broker;
#[repr(C)]
pub struct rd_kafka_metadata_partition {
    pub id: i32,
    pub err: rd_kafka_resp_err_t,
    pub leader: i32,
    pub replica_cnt: c_int,
    pub replicas: *mut i32,
    pub isr_cnt: c_int,
    pub isrs: *mut i32,
}
pub type rd_kafka_metadata_partition_t = rd_kafka_metadata_partition;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_metadata_topic {
    pub topic: *mut c_char,
    pub partition_cnt: c_int,
    pub partitions: *mut rd_kafka_metadata_partition,
    pub err: rd_kafka_resp_err_t,
}
pub type rd_kafka_metadata_topic_t = rd_kafka_metadata_topic;
#[repr(C)]
pub struct rd_kafka_metadata {
    pub broker_cnt: c_int,
    pub brokers: *mut rd_kafka_metadata_broker,
    pub topic_cnt: c_int,
    pub topics: *mut rd_kafka_metadata_topic,
    pub orig_broker_id: i32,
    pub orig_broker_name: *mut c_char,
}
pub type rd_kafka_metadata_t = rd_kafka_metadata;
extern "C" {
    pub fn rd_kafka_metadata(
        rk: *mut rd_kafka_t,
        all_topics: c_int,
        only_rkt: *mut rd_kafka_topic_t,
        metadatap: *mut *const rd_kafka_metadata,
        timeout_ms: c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_metadata_destroy(metadata: *const rd_kafka_metadata);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_group_member_info {
    pub member_id: *mut c_char,
    pub client_id: *mut c_char,
    pub client_host: *mut c_char,
    pub member_metadata: *mut c_void,
    pub member_metadata_size: c_int,
    pub member_assignment: *mut c_void,
    pub member_assignment_size: c_int,
}
#[repr(C)]
pub struct rd_kafka_group_info {
    pub broker: rd_kafka_metadata_broker,
    pub group: *mut c_char,
    pub err: rd_kafka_resp_err_t,
    pub state: *mut c_char,
    pub protocol_type: *mut c_char,
    pub protocol: *mut c_char,
    pub members: *mut rd_kafka_group_member_info,
    pub member_cnt: c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_group_list {
    pub groups: *mut rd_kafka_group_info,
    pub group_cnt: c_int,
}
extern "C" {
    pub fn rd_kafka_list_groups(
        rk: *mut rd_kafka_t,
        group: *const c_char,
        grplistp: *mut *const rd_kafka_group_list,
        timeout_ms: c_int,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_group_list_destroy(grplist: *const rd_kafka_group_list);
}
extern "C" {
    pub fn rd_kafka_brokers_add(rk: *mut rd_kafka_t, brokerlist: *const c_char) -> c_int;
}
extern "C" {
    pub fn rd_kafka_set_logger(
        rk: *mut rd_kafka_t,
        func: Option<
            unsafe extern "C" fn(
                rk: *const rd_kafka_t,
                level: c_int,
                fac: *const c_char,
                buf: *const c_char,
            ),
        >,
    );
}
extern "C" {
    pub fn rd_kafka_set_log_level(rk: *mut rd_kafka_t, level: c_int);
}
extern "C" {
    pub fn rd_kafka_log_print(
        rk: *const rd_kafka_t,
        level: c_int,
        fac: *const c_char,
        buf: *const c_char,
    );
}
extern "C" {
    pub fn rd_kafka_log_syslog(
        rk: *const rd_kafka_t,
        level: c_int,
        fac: *const c_char,
        buf: *const c_char,
    );
}
extern "C" {
    pub fn rd_kafka_outq_len(rk: *mut rd_kafka_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_dump(fp: *mut FILE, rk: *mut rd_kafka_t);
}
extern "C" {
    pub fn rd_kafka_thread_cnt() -> c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_thread_type_t {
    RD_KAFKA_THREAD_MAIN = 0,
    RD_KAFKA_THREAD_BACKGROUND = 1,
    RD_KAFKA_THREAD_BROKER = 2,
}
extern "C" {
    pub fn rd_kafka_wait_destroyed(timeout_ms: c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_kafka_unittest() -> c_int;
}
extern "C" {
    pub fn rd_kafka_poll_set_consumer(rk: *mut rd_kafka_t) -> rd_kafka_resp_err_t;
}
pub type rd_kafka_event_type_t = c_int;
extern "C" {
    pub fn rd_kafka_event_type(rkev: *const rd_kafka_event_t) -> rd_kafka_event_type_t;
}
extern "C" {
    pub fn rd_kafka_event_name(rkev: *const rd_kafka_event_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_event_destroy(rkev: *mut rd_kafka_event_t);
}
extern "C" {
    pub fn rd_kafka_event_message_next(rkev: *mut rd_kafka_event_t) -> *const rd_kafka_message_t;
}
extern "C" {
    pub fn rd_kafka_event_message_array(
        rkev: *mut rd_kafka_event_t,
        rkmessages: *mut *const rd_kafka_message_t,
        size: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rd_kafka_event_message_count(rkev: *mut rd_kafka_event_t) -> size_t;
}
extern "C" {
    pub fn rd_kafka_event_config_string(rkev: *mut rd_kafka_event_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_event_error(rkev: *mut rd_kafka_event_t) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_event_error_string(rkev: *mut rd_kafka_event_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_event_error_is_fatal(rkev: *mut rd_kafka_event_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_event_opaque(rkev: *mut rd_kafka_event_t) -> *mut c_void;
}
extern "C" {
    pub fn rd_kafka_event_log(
        rkev: *mut rd_kafka_event_t,
        fac: *mut *const c_char,
        str_: *mut *const c_char,
        level: *mut c_int,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_event_debug_contexts(
        rkev: *mut rd_kafka_event_t,
        dst: *mut c_char,
        dstsize: size_t,
    ) -> c_int;
}
extern "C" {
    pub fn rd_kafka_event_stats(rkev: *mut rd_kafka_event_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_event_topic_partition_list(
        rkev: *mut rd_kafka_event_t,
    ) -> *mut rd_kafka_topic_partition_list_t;
}
extern "C" {
    pub fn rd_kafka_event_topic_partition(
        rkev: *mut rd_kafka_event_t,
    ) -> *mut rd_kafka_topic_partition_t;
}
pub type rd_kafka_CreateTopics_result_t = rd_kafka_event_t;
pub type rd_kafka_DeleteTopics_result_t = rd_kafka_event_t;
pub type rd_kafka_CreatePartitions_result_t = rd_kafka_event_t;
pub type rd_kafka_AlterConfigs_result_t = rd_kafka_event_t;
pub type rd_kafka_DescribeConfigs_result_t = rd_kafka_event_t;
pub type rd_kafka_DeleteRecords_result_t = rd_kafka_event_t;
pub type rd_kafka_DeleteGroups_result_t = rd_kafka_event_t;
pub type rd_kafka_DeleteConsumerGroupOffsets_result_t = rd_kafka_event_t;
extern "C" {
    pub fn rd_kafka_event_CreateTopics_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_CreateTopics_result_t;
}
extern "C" {
    pub fn rd_kafka_event_DeleteTopics_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_DeleteTopics_result_t;
}
extern "C" {
    pub fn rd_kafka_event_CreatePartitions_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_CreatePartitions_result_t;
}
extern "C" {
    pub fn rd_kafka_event_AlterConfigs_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_AlterConfigs_result_t;
}
extern "C" {
    pub fn rd_kafka_event_DescribeConfigs_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_DescribeConfigs_result_t;
}
extern "C" {
    pub fn rd_kafka_event_DeleteRecords_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_DeleteRecords_result_t;
}
extern "C" {
    pub fn rd_kafka_event_DeleteGroups_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_DeleteGroups_result_t;
}
extern "C" {
    pub fn rd_kafka_event_DeleteConsumerGroupOffsets_result(
        rkev: *mut rd_kafka_event_t,
    ) -> *const rd_kafka_DeleteConsumerGroupOffsets_result_t;
}
extern "C" {
    pub fn rd_kafka_queue_poll(
        rkqu: *mut rd_kafka_queue_t,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_event_t;
}
extern "C" {
    pub fn rd_kafka_queue_poll_callback(rkqu: *mut rd_kafka_queue_t, timeout_ms: c_int) -> c_int;
}
pub type rd_kafka_plugin_f_conf_init_t = Option<
    unsafe extern "C" fn(
        conf: *mut rd_kafka_conf_t,
        plug_opaquep: *mut *mut c_void,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_conf_set_t = Option<
    unsafe extern "C" fn(
        conf: *mut rd_kafka_conf_t,
        name: *const c_char,
        val: *const c_char,
        errstr: *mut c_char,
        errstr_size: size_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_conf_res_t,
>;
pub type rd_kafka_interceptor_f_on_conf_dup_t = Option<
    unsafe extern "C" fn(
        new_conf: *mut rd_kafka_conf_t,
        old_conf: *const rd_kafka_conf_t,
        filter_cnt: size_t,
        filter: *mut *const c_char,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_conf_destroy_t =
    Option<unsafe extern "C" fn(ic_opaque: *mut c_void) -> rd_kafka_resp_err_t>;
pub type rd_kafka_interceptor_f_on_new_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        conf: *const rd_kafka_conf_t,
        ic_opaque: *mut c_void,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_destroy_t = Option<
    unsafe extern "C" fn(rk: *mut rd_kafka_t, ic_opaque: *mut c_void) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_send_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        rkmessage: *mut rd_kafka_message_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_acknowledgement_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        rkmessage: *mut rd_kafka_message_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_consume_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        rkmessage: *mut rd_kafka_message_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_commit_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        offsets: *const rd_kafka_topic_partition_list_t,
        err: rd_kafka_resp_err_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_request_sent_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        sockfd: c_int,
        brokername: *const c_char,
        brokerid: i32,
        ApiKey: i16,
        ApiVersion: i16,
        CorrId: i32,
        size: size_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_response_received_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        sockfd: c_int,
        brokername: *const c_char,
        brokerid: i32,
        ApiKey: i16,
        ApiVersion: i16,
        CorrId: i32,
        size: size_t,
        rtt: i64,
        err: rd_kafka_resp_err_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_thread_start_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        thread_type: rd_kafka_thread_type_t,
        thread_name: *const c_char,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
pub type rd_kafka_interceptor_f_on_thread_exit_t = Option<
    unsafe extern "C" fn(
        rk: *mut rd_kafka_t,
        thread_type: rd_kafka_thread_type_t,
        thread_name: *const c_char,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t,
>;
extern "C" {
    pub fn rd_kafka_conf_interceptor_add_on_conf_set(
        conf: *mut rd_kafka_conf_t,
        ic_name: *const c_char,
        on_conf_set: rd_kafka_interceptor_f_on_conf_set_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_conf_interceptor_add_on_conf_dup(
        conf: *mut rd_kafka_conf_t,
        ic_name: *const c_char,
        on_conf_dup: rd_kafka_interceptor_f_on_conf_dup_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_conf_interceptor_add_on_conf_destroy(
        conf: *mut rd_kafka_conf_t,
        ic_name: *const c_char,
        on_conf_destroy: rd_kafka_interceptor_f_on_conf_destroy_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_conf_interceptor_add_on_new(
        conf: *mut rd_kafka_conf_t,
        ic_name: *const c_char,
        on_new: rd_kafka_interceptor_f_on_new_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_destroy(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_destroy: rd_kafka_interceptor_f_on_destroy_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_send(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_send: rd_kafka_interceptor_f_on_send_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_acknowledgement(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_acknowledgement: rd_kafka_interceptor_f_on_acknowledgement_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_consume(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_consume: rd_kafka_interceptor_f_on_consume_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_commit(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_commit: rd_kafka_interceptor_f_on_commit_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_request_sent(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_request_sent: rd_kafka_interceptor_f_on_request_sent_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_response_received(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_response_received: rd_kafka_interceptor_f_on_response_received_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_thread_start(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_thread_start: rd_kafka_interceptor_f_on_thread_start_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_interceptor_add_on_thread_exit(
        rk: *mut rd_kafka_t,
        ic_name: *const c_char,
        on_thread_exit: rd_kafka_interceptor_f_on_thread_exit_t,
        ic_opaque: *mut c_void,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_topic_result_error(
        topicres: *const rd_kafka_topic_result_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_topic_result_error_string(
        topicres: *const rd_kafka_topic_result_t,
    ) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_topic_result_name(topicres: *const rd_kafka_topic_result_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_group_result_error(
        groupres: *const rd_kafka_group_result_t,
    ) -> *const rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_group_result_name(groupres: *const rd_kafka_group_result_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_group_result_partitions(
        groupres: *const rd_kafka_group_result_t,
    ) -> *const rd_kafka_topic_partition_list_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_admin_op_t {
    RD_KAFKA_ADMIN_OP_ANY = 0,
    RD_KAFKA_ADMIN_OP_CREATETOPICS = 1,
    RD_KAFKA_ADMIN_OP_DELETETOPICS = 2,
    RD_KAFKA_ADMIN_OP_CREATEPARTITIONS = 3,
    RD_KAFKA_ADMIN_OP_ALTERCONFIGS = 4,
    RD_KAFKA_ADMIN_OP_DESCRIBECONFIGS = 5,
    RD_KAFKA_ADMIN_OP_DELETERECORDS = 6,
    RD_KAFKA_ADMIN_OP_DELETEGROUPS = 7,
    RD_KAFKA_ADMIN_OP_DELETECONSUMERGROUPOFFSETS = 8,
    RD_KAFKA_ADMIN_OP__CNT = 9,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_AdminOptions_s {
    _unused: [u8; 0],
}
pub type rd_kafka_AdminOptions_t = rd_kafka_AdminOptions_s;
extern "C" {
    pub fn rd_kafka_AdminOptions_new(
        rk: *mut rd_kafka_t,
        for_api: rd_kafka_admin_op_t,
    ) -> *mut rd_kafka_AdminOptions_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_destroy(options: *mut rd_kafka_AdminOptions_t);
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_request_timeout(
        options: *mut rd_kafka_AdminOptions_t,
        timeout_ms: c_int,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_operation_timeout(
        options: *mut rd_kafka_AdminOptions_t,
        timeout_ms: c_int,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_validate_only(
        options: *mut rd_kafka_AdminOptions_t,
        true_or_false: c_int,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_broker(
        options: *mut rd_kafka_AdminOptions_t,
        broker_id: i32,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_AdminOptions_set_opaque(
        options: *mut rd_kafka_AdminOptions_t,
        ev_opaque: *mut c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_NewTopic_s {
    _unused: [u8; 0],
}
pub type rd_kafka_NewTopic_t = rd_kafka_NewTopic_s;
extern "C" {
    pub fn rd_kafka_NewTopic_new(
        topic: *const c_char,
        num_partitions: c_int,
        replication_factor: c_int,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> *mut rd_kafka_NewTopic_t;
}
extern "C" {
    pub fn rd_kafka_NewTopic_destroy(new_topic: *mut rd_kafka_NewTopic_t);
}
extern "C" {
    pub fn rd_kafka_NewTopic_destroy_array(
        new_topics: *mut *mut rd_kafka_NewTopic_t,
        new_topic_cnt: size_t,
    );
}
extern "C" {
    pub fn rd_kafka_NewTopic_set_replica_assignment(
        new_topic: *mut rd_kafka_NewTopic_t,
        partition: i32,
        broker_ids: *mut i32,
        broker_id_cnt: size_t,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_NewTopic_set_config(
        new_topic: *mut rd_kafka_NewTopic_t,
        name: *const c_char,
        value: *const c_char,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_CreateTopics(
        rk: *mut rd_kafka_t,
        new_topics: *mut *mut rd_kafka_NewTopic_t,
        new_topic_cnt: size_t,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_CreateTopics_result_topics(
        result: *const rd_kafka_CreateTopics_result_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_topic_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_DeleteTopic_s {
    _unused: [u8; 0],
}
pub type rd_kafka_DeleteTopic_t = rd_kafka_DeleteTopic_s;
extern "C" {
    pub fn rd_kafka_DeleteTopic_new(topic: *const c_char) -> *mut rd_kafka_DeleteTopic_t;
}
extern "C" {
    pub fn rd_kafka_DeleteTopic_destroy(del_topic: *mut rd_kafka_DeleteTopic_t);
}
extern "C" {
    pub fn rd_kafka_DeleteTopic_destroy_array(
        del_topics: *mut *mut rd_kafka_DeleteTopic_t,
        del_topic_cnt: size_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteTopics(
        rk: *mut rd_kafka_t,
        del_topics: *mut *mut rd_kafka_DeleteTopic_t,
        del_topic_cnt: size_t,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteTopics_result_topics(
        result: *const rd_kafka_DeleteTopics_result_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_topic_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_NewPartitions_s {
    _unused: [u8; 0],
}
pub type rd_kafka_NewPartitions_t = rd_kafka_NewPartitions_s;
extern "C" {
    pub fn rd_kafka_NewPartitions_new(
        topic: *const c_char,
        new_total_cnt: size_t,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> *mut rd_kafka_NewPartitions_t;
}
extern "C" {
    pub fn rd_kafka_NewPartitions_destroy(new_parts: *mut rd_kafka_NewPartitions_t);
}
extern "C" {
    pub fn rd_kafka_NewPartitions_destroy_array(
        new_parts: *mut *mut rd_kafka_NewPartitions_t,
        new_parts_cnt: size_t,
    );
}
extern "C" {
    pub fn rd_kafka_NewPartitions_set_replica_assignment(
        new_parts: *mut rd_kafka_NewPartitions_t,
        new_partition_idx: i32,
        broker_ids: *mut i32,
        broker_id_cnt: size_t,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_CreatePartitions(
        rk: *mut rd_kafka_t,
        new_parts: *mut *mut rd_kafka_NewPartitions_t,
        new_parts_cnt: size_t,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_CreatePartitions_result_topics(
        result: *const rd_kafka_CreatePartitions_result_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_topic_result_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_ConfigSource_t {
    RD_KAFKA_CONFIG_SOURCE_UNKNOWN_CONFIG = 0,
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_TOPIC_CONFIG = 1,
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_BROKER_CONFIG = 2,
    RD_KAFKA_CONFIG_SOURCE_DYNAMIC_DEFAULT_BROKER_CONFIG = 3,
    RD_KAFKA_CONFIG_SOURCE_STATIC_BROKER_CONFIG = 4,
    RD_KAFKA_CONFIG_SOURCE_DEFAULT_CONFIG = 5,
    RD_KAFKA_CONFIG_SOURCE__CNT = 6,
}
extern "C" {
    pub fn rd_kafka_ConfigSource_name(confsource: rd_kafka_ConfigSource_t) -> *const c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_ConfigEntry_s {
    _unused: [u8; 0],
}
pub type rd_kafka_ConfigEntry_t = rd_kafka_ConfigEntry_s;
extern "C" {
    pub fn rd_kafka_ConfigEntry_name(entry: *const rd_kafka_ConfigEntry_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_value(entry: *const rd_kafka_ConfigEntry_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_source(
        entry: *const rd_kafka_ConfigEntry_t,
    ) -> rd_kafka_ConfigSource_t;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_is_read_only(entry: *const rd_kafka_ConfigEntry_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_is_default(entry: *const rd_kafka_ConfigEntry_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_is_sensitive(entry: *const rd_kafka_ConfigEntry_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_is_synonym(entry: *const rd_kafka_ConfigEntry_t) -> c_int;
}
extern "C" {
    pub fn rd_kafka_ConfigEntry_synonyms(
        entry: *const rd_kafka_ConfigEntry_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_ConfigEntry_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rd_kafka_ResourceType_t {
    RD_KAFKA_RESOURCE_UNKNOWN = 0,
    RD_KAFKA_RESOURCE_ANY = 1,
    RD_KAFKA_RESOURCE_TOPIC = 2,
    RD_KAFKA_RESOURCE_GROUP = 3,
    RD_KAFKA_RESOURCE_BROKER = 4,
    RD_KAFKA_RESOURCE__CNT = 5,
}
extern "C" {
    pub fn rd_kafka_ResourceType_name(restype: rd_kafka_ResourceType_t) -> *const c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_ConfigResource_s {
    _unused: [u8; 0],
}
pub type rd_kafka_ConfigResource_t = rd_kafka_ConfigResource_s;
extern "C" {
    pub fn rd_kafka_ConfigResource_new(
        restype: rd_kafka_ResourceType_t,
        resname: *const c_char,
    ) -> *mut rd_kafka_ConfigResource_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_destroy(config: *mut rd_kafka_ConfigResource_t);
}
extern "C" {
    pub fn rd_kafka_ConfigResource_destroy_array(
        config: *mut *mut rd_kafka_ConfigResource_t,
        config_cnt: size_t,
    );
}
extern "C" {
    pub fn rd_kafka_ConfigResource_set_config(
        config: *mut rd_kafka_ConfigResource_t,
        name: *const c_char,
        value: *const c_char,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_configs(
        config: *const rd_kafka_ConfigResource_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_ConfigEntry_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_type(
        config: *const rd_kafka_ConfigResource_t,
    ) -> rd_kafka_ResourceType_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_name(config: *const rd_kafka_ConfigResource_t) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_error(
        config: *const rd_kafka_ConfigResource_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_ConfigResource_error_string(
        config: *const rd_kafka_ConfigResource_t,
    ) -> *const c_char;
}
extern "C" {
    pub fn rd_kafka_AlterConfigs(
        rk: *mut rd_kafka_t,
        configs: *mut *mut rd_kafka_ConfigResource_t,
        config_cnt: size_t,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_AlterConfigs_result_resources(
        result: *const rd_kafka_AlterConfigs_result_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_ConfigResource_t;
}
extern "C" {
    pub fn rd_kafka_DescribeConfigs(
        rk: *mut rd_kafka_t,
        configs: *mut *mut rd_kafka_ConfigResource_t,
        config_cnt: size_t,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_DescribeConfigs_result_resources(
        result: *const rd_kafka_DescribeConfigs_result_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_ConfigResource_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_DeleteRecords_s {
    _unused: [u8; 0],
}
pub type rd_kafka_DeleteRecords_t = rd_kafka_DeleteRecords_s;
extern "C" {
    pub fn rd_kafka_DeleteRecords_new(
        before_offsets: *const rd_kafka_topic_partition_list_t,
    ) -> *mut rd_kafka_DeleteRecords_t;
}
extern "C" {
    pub fn rd_kafka_DeleteRecords_destroy(del_records: *mut rd_kafka_DeleteRecords_t);
}
extern "C" {
    pub fn rd_kafka_DeleteRecords_destroy_array(
        del_records: *mut *mut rd_kafka_DeleteRecords_t,
        del_record_cnt: size_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteRecords(
        rk: *mut rd_kafka_t,
        del_records: *mut *mut rd_kafka_DeleteRecords_t,
        del_record_cnt: size_t,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteRecords_result_offsets(
        result: *const rd_kafka_DeleteRecords_result_t,
    ) -> *const rd_kafka_topic_partition_list_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_DeleteGroup_s {
    _unused: [u8; 0],
}
pub type rd_kafka_DeleteGroup_t = rd_kafka_DeleteGroup_s;
extern "C" {
    pub fn rd_kafka_DeleteGroup_new(group: *const c_char) -> *mut rd_kafka_DeleteGroup_t;
}
extern "C" {
    pub fn rd_kafka_DeleteGroup_destroy(del_group: *mut rd_kafka_DeleteGroup_t);
}
extern "C" {
    pub fn rd_kafka_DeleteGroup_destroy_array(
        del_groups: *mut *mut rd_kafka_DeleteGroup_t,
        del_group_cnt: size_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteGroups(
        rk: *mut rd_kafka_t,
        del_groups: *mut *mut rd_kafka_DeleteGroup_t,
        del_group_cnt: size_t,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteGroups_result_groups(
        result: *const rd_kafka_DeleteGroups_result_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_group_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rd_kafka_DeleteConsumerGroupOffsets_s {
    _unused: [u8; 0],
}
pub type rd_kafka_DeleteConsumerGroupOffsets_t = rd_kafka_DeleteConsumerGroupOffsets_s;
extern "C" {
    pub fn rd_kafka_DeleteConsumerGroupOffsets_new(
        group: *const c_char,
        partitions: *const rd_kafka_topic_partition_list_t,
    ) -> *mut rd_kafka_DeleteConsumerGroupOffsets_t;
}
extern "C" {
    pub fn rd_kafka_DeleteConsumerGroupOffsets_destroy(
        del_grpoffsets: *mut rd_kafka_DeleteConsumerGroupOffsets_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteConsumerGroupOffsets_destroy_array(
        del_grpoffsets: *mut *mut rd_kafka_DeleteConsumerGroupOffsets_t,
        del_grpoffset_cnt: size_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteConsumerGroupOffsets(
        rk: *mut rd_kafka_t,
        del_grpoffsets: *mut *mut rd_kafka_DeleteConsumerGroupOffsets_t,
        del_grpoffsets_cnt: size_t,
        options: *const rd_kafka_AdminOptions_t,
        rkqu: *mut rd_kafka_queue_t,
    );
}
extern "C" {
    pub fn rd_kafka_DeleteConsumerGroupOffsets_result_groups(
        result: *const rd_kafka_DeleteConsumerGroupOffsets_result_t,
        cntp: *mut size_t,
    ) -> *mut *const rd_kafka_group_result_t;
}
extern "C" {
    pub fn rd_kafka_oauthbearer_set_token(
        rk: *mut rd_kafka_t,
        token_value: *const c_char,
        md_lifetime_ms: i64,
        md_principal_name: *const c_char,
        extensions: *mut *const c_char,
        extension_size: size_t,
        errstr: *mut c_char,
        errstr_size: size_t,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_oauthbearer_set_token_failure(
        rk: *mut rd_kafka_t,
        errstr: *const c_char,
    ) -> rd_kafka_resp_err_t;
}
extern "C" {
    pub fn rd_kafka_init_transactions(
        rk: *mut rd_kafka_t,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_begin_transaction(rk: *mut rd_kafka_t) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_send_offsets_to_transaction(
        rk: *mut rd_kafka_t,
        offsets: *const rd_kafka_topic_partition_list_t,
        cgmetadata: *const rd_kafka_consumer_group_metadata_t,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_commit_transaction(
        rk: *mut rd_kafka_t,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_error_t;
}
extern "C" {
    pub fn rd_kafka_abort_transaction(
        rk: *mut rd_kafka_t,
        timeout_ms: c_int,
    ) -> *mut rd_kafka_error_t;
}
